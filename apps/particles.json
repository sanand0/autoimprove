[
  {
    "role": "system",
    "content": "Generate a single page HTML app in a single Markdown code block.\nALWAYS end with a ONE-LINE information-rich summary of the change. Begin the line with ðŸ’¡"
  },
  {
    "role": "user",
    "content": "Create an interactive particle simulation"
  },
  {
    "role": "assistant",
    "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n<title>Interactive Particle Simulation</title>\n<style>\n  html, body {\n    margin: 0;\n    overflow: hidden;\n    background-color: #000;\n  }\n  canvas {\n    display: block;\n  }\n</style>\n</head>\n<body>\n<canvas id=\"canvas\"></canvas>\n<script>\nconst canvas = document.getElementById('canvas');\nconst ctx = canvas.getContext('2d');\n\nlet width = window.innerWidth;\nlet height = window.innerHeight;\n\ncanvas.width = width;\ncanvas.height = height;\n\nwindow.addEventListener('resize', () => {\n  width = window.innerWidth;\n  height = window.innerHeight;\n  canvas.width = width;\n  canvas.height = height;\n});\n\n// Particle class\nclass Particle {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n    const angle = Math.random() * 2 * Math.PI;\n    const speed = Math.random() * 2 + 1;\n    this.vx = Math.cos(angle) * speed;\n    this.vy = Math.sin(angle) * speed;\n    this.size = 2;\n  }\n\n  update() {\n    this.x += this.vx;\n    this.y += this.vy;\n    // Bounce off edges\n    if (this.x < 0 || this.x > width) {\n      this.vx *= -1;\n    }\n    if (this.y < 0 || this.y > height) {\n      this.vy *= -1;\n    }\n  }\n\n  draw() {\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n    ctx.fillStyle = 'white';\n    ctx.fill();\n  }\n}\n\nconst particles = [];\nconst maxParticles = 200;\n\n// Initialize particles\nfor (let i = 0; i < maxParticles; i++) {\n  particles.push(new Particle(Math.random() * width, Math.random() * height));\n}\n\n// Interaction variables\nconst mouse = { x: null, y: null, radius: 100 };\n\ncanvas.addEventListener('mousemove', e => {\n  mouse.x = e.clientX;\n  mouse.y = e.clientY;\n});\ncanvas.addEventListener('mouseleave', () => {\n  mouse.x = null;\n  mouse.y = null;\n});\n\n// Main animation loop\nfunction animate() {\n  ctx.clearRect(0, 0, width, height);\n\n  // Update and draw particles\n  for (let p of particles) {\n    p.update();\n    p.draw();\n  }\n\n  // Draw connections\n  for (let i = 0; i < particles.length; i++) {\n    for (let j = i + 1; j < particles.length; j++) {\n      const dx = particles[i].x - particles[j].x;\n      const dy = particles[i].y - particles[j].y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n      if (dist < 100) {\n        ctx.strokeStyle = `rgba(255,255,255,${1 - dist/100})`;\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n        ctx.moveTo(particles[i].x, particles[i].y);\n        ctx.lineTo(particles[j].x, particles[j].y);\n        ctx.stroke();\n      }\n    }\n  }\n\n  // Connect particles to mouse if nearby\n  if (mouse.x !== null && mouse.y !== null) {\n    for (let p of particles) {\n      const dx = p.x - mouse.x;\n      const dy = p.y - mouse.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n      if (dist < mouse.radius) {\n        ctx.strokeStyle = `rgba(255,255,255,${1 - dist/mouse.radius})`;\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n        ctx.moveTo(p.x, p.y);\n        ctx.lineTo(mouse.x, mouse.y);\n        ctx.stroke();\n        // Optional: particles move away from cursor\n        const angle = Math.atan2(dy, dx);\n        p.vx += Math.cos(angle) * 0.05;\n        p.vy += Math.sin(angle) * 0.05;\n      }\n    }\n  }\n\n  requestAnimationFrame(animate);\n}\n\nanimate();\n</script>\n</body>\n</html>\n```\nðŸ’¡This code creates an interactive particle simulation with particles bouncing off edges, connecting to each other and to the mouse pointer with lines, enhancing user engagement."
  },
  {
    "role": "user",
    "content": "Improve this further - dramatically!"
  },
  {
    "role": "assistant",
    "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n<title>Enhanced Interactive Particle System</title>\n<style>\n  html, body {\n    margin: 0;\n    overflow: hidden;\n    background: radial-gradient(ellipse at center, #000 0%, #020202 100%);\n  }\n  canvas {\n    display: block;\n    cursor: none;\n  }\n</style>\n</head>\n<body>\n<canvas id=\"canvas\"></canvas>\n<script>\nconst canvas = document.getElementById('canvas');\nconst ctx = canvas.getContext('2d');\n\nlet width = window.innerWidth;\nlet height = window.innerHeight;\n\ncanvas.width = width;\ncanvas.height = height;\n\nwindow.addEventListener('resize', () => {\n  width = window.innerWidth;\n  height = window.innerHeight;\n  canvas.width = width;\n  canvas.height = height;\n});\n\n// Utility functions\nfunction randRange(a, b) {\n  return Math.random() * (b - a) + a;\n}\n\n// Particle class with more features\nclass Particle {\n  constructor() {\n    this.reset();\n  }\n  reset() {\n    this.x = randRange(0, width);\n    this.y = randRange(0, height);\n    const angle = randRange(0, 2*Math.PI);\n    const speed = randRange(0.5, 3);\n    this.vx = Math.cos(angle) * speed;\n    this.vy = Math.sin(angle) * speed;\n    this.size = randRange(1, 3);\n    this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;\n    this.life = randRange(60, 180);\n    this.alpha = 1;\n    this.drag = 0.98;\n    this.colorShiftSpeed = randRange(0.2, 1);\n  }\n  update() {\n    this.x += this.vx;\n    this.y += this.vy;\n\n    // Bounce with damping\n    if (this.x < 0 || this.x > width) {\n      this.vx *= -1;\n      this.x = Math.max(0, Math.min(this.x, width));\n    }\n    if (this.y < 0 || this.y > height) {\n      this.vy *= -1;\n      this.y = Math.max(0, Math.min(this.y, height));\n    }\n\n    // Apply drag\n    this.vx *= this.drag;\n    this.vy *= this.drag;\n\n    // Life decrement\n    this.life--;\n    if (this.life <= 0) {\n      this.reset();\n    }\n  }\n  draw() {\n    ctx.globalAlpha = this.alpha;\n    ctx.fillStyle = this.color;\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.globalAlpha = 1;\n  }\n}\n\n// Initialize particles\nconst particles = [];\nconst maxParticles = 300;\nfor (let i=0; i<maxParticles; i++) {\n  particles.push(new Particle());\n}\n\n// Mouse interaction\nconst mouse = { x: null, y: null, radius: 150, vx: 0, vy: 0 };\nwindow.addEventListener('mousemove', e => {\n  const prevX = mouse.x;\n  const prevY = mouse.y;\n  mouse.x = e.clientX;\n  mouse.y = e.clientY;\n  if (prevX !== null && prevY !== null) {\n    mouse.vx = (mouse.x - prevX) * 0.2;\n    mouse.vy = (mouse.y - prevY) * 0.2;\n  }\n});\nwindow.addEventListener('mouseleave', () => {\n  mouse.x = null;\n  mouse.y = null;\n  mouse.vx = 0;\n  mouse.vy = 0;\n});\n\n// Animation loop\nfunction animate() {\n  ctx.fillStyle = 'rgba(0,0,0,0.2)';\n  ctx.fillRect(0, 0, width, height);\n\n  // Update particles\n  for (let p of particles) {\n    p.update();\n    p.draw();\n  }\n\n  // Draw connections between close particles\n  for (let i=0; i<particles.length; i++) {\n    for (let j=i+1; j<particles.length; j++) {\n      const dx = particles[i].x - particles[j].x;\n      const dy = particles[i].y - particles[j].y;\n      const dist = Math.sqrt(dx*dx + dy*dy);\n      if (dist < 100) {\n        ctx.strokeStyle = `rgba(255,255,255,${0.2 + 0.8*(1 - dist/100)})`;\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n        ctx.moveTo(particles[i].x, particles[i].y);\n        ctx.lineTo(particles[j].x, particles[j].y);\n        ctx.stroke();\n      }\n    }\n  }\n\n  // Connect particles to mouse with motion\n  if (mouse.x !== null && mouse.y !== null) {\n    for (let p of particles) {\n      const dx = p.x - mouse.x;\n      const dy = p.y - mouse.y;\n      const dist = Math.sqrt(dx*dx + dy*dy);\n      if (dist < mouse.radius) {\n        // line to mouse\n        ctx.strokeStyle = `rgba(255,255,255,${0.4 + 0.6*(1 - dist/mouse.radius)})`;\n        ctx.lineWidth = 1.2;\n        ctx.beginPath();\n        ctx.moveTo(p.x, p.y);\n        ctx.lineTo(mouse.x, mouse.y);\n        ctx.stroke();\n\n        // apply repulsion\n        const force = (mouse.radius - dist) / mouse.radius;\n        const angle = Math.atan2(dy, dx);\n        p.vx += Math.cos(angle) * force * 0.5;\n        p.vy += Math.sin(angle) * force * 0.5;\n\n        // also add a slight attraction to cursor for particles close\n        p.vx -= Math.cos(angle) * force * 0.05;\n        p.vy -= Math.sin(angle) * force * 0.05;\n      }\n    }\n    // add momentum to mouse\n    mouse.x += mouse.vx;\n    mouse.y += mouse.vy;\n    // decay mouse velocity\n    mouse.vx *= 0.95;\n    mouse.vy *= 0.95;\n  }\n\n  requestAnimationFrame(animate);\n}\n\nanimate();\n</script>\n</body>\n</html>\n```\nðŸ’¡This version dramatically enhances the simulation by increasing particle count, adding vibrant colors, stochastic motion, fading trails, and dynamic mouse interaction with momentum and repulsion, producing a rich, mesmerizing visual experience."
  },
  {
    "role": "user",
    "content": "Improve this further - dramatically!"
  },
  {
    "role": "assistant",
    "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n<title>Ultimate Adaptive Particle Explosion</title>\n<style>\n  html, body {\n    margin: 0;\n    overflow: hidden;\n    background: radial-gradient(ellipse at center, #000 0%, #030303 100%);\n  }\n  canvas {\n    display: block;\n    cursor: none;\n  }\n</style>\n</head>\n<body>\n<canvas id=\"canvas\"></canvas>\n<script>\nconst canvas = document.getElementById('canvas');\nconst ctx = canvas.getContext('2d');\n\nlet width = window.innerWidth;\nlet height = window.innerHeight;\n\ncanvas.width = width;\ncanvas.height = height;\nwindow.addEventListener('resize', () => {\n  width = window.innerWidth;\n  height = window.innerHeight;\n  canvas.width = width;\n  canvas.height = height;\n});\n\n// Utility functions\nfunction randRange(a, b) {\n  return Math.random() * (b - a) + a;\n}\n\nclass Particle {\n  constructor() {\n    this.reset();\n  }\n  reset() {\n    // Spawn everywhere with explosive variation\n    if (Math.random() < 0.5) {\n      this.x = randRange(0, width);\n      this.y = randRange(0, height);\n    } else {\n      this.x = width/2 + randRange(-50,50);\n      this.y = height/2 + randRange(-50,50);\n    }\n    const angle = randRange(0, 2*Math.PI);\n    const speed = randRange(1, 6);\n    this.vx = Math.cos(angle) * speed;\n    this.vy = Math.sin(angle) * speed;\n    this.size = randRange(1, 4);\n    this.color = `hsl(${Math.random() * 360}, 80%, 60%)`;\n    this.life = randRange(80, 250);\n    this.alpha = 1;\n    this.drag = 0.97;\n    this.friction = 0.99;\n    this.accelFactor = randRange(0.02, 0.1);\n  }\n  update() {\n    // Apply gravity for explosion effect\n    this.vy += 0.02;\n\n    // Apply drag\n    this.vx *= this.drag;\n    this.vy *= this.drag;\n\n    // Move\n    this.x += this.vx;\n    this.y += this.vy;\n\n    // Bounce walls with energy loss\n    if (this.x < 0) { this.x=0; this.vx*=-1; this.vx*=0.7; }\n    if (this.x > width) { this.x=width; this.vx*=-1; this.vx*=0.7; }\n    if (this.y < 0) { this.y=0; this.vy*=-1; this.vy*=0.7; }\n    if (this.y > height) { this.y=height; this.vy*=-1; this.vy*=0.7; }\n\n    // Fade out over lifespan\n    this.life--;\n    if (this.life <=0 || this.size<=0.2) {\n      this.reset();\n    }\n\n    // Diminish size\n    this.size *= 0.995;\n  }\n  draw() {\n    ctx.globalAlpha = Math.min(this.alpha, this.life/250);\n    ctx.fillStyle = this.color;\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);\n    ctx.fill();\n    ctx.globalAlpha=1;\n  }\n}\n\n// Initialize particles with explosion burst\nconst particles = [];\nconst maxParticles = 1000;\nfor (let i=0;i<maxParticles;i++) {\n  particles.push(new Particle());\n}\n\n// Mouse interaction with momentum\nconst mouse = { x:null, y:null, vx:0, vy:0, radius:200};\nwindow.addEventListener('mousemove', e => {\n  if (mouse.x!==null && mouse.y!==null) {\n    mouse.vx = (e.clientX - mouse.x)*0.2;\n    mouse.vy = (e.clientY - mouse.y)*0.2;\n  }\n  mouse.x = e.clientX;\n  mouse.y = e.clientY;\n});\nwindow.addEventListener('mouseleave', ()=> {\n  mouse.x = null;\n  mouse.y = null;\n  mouse.vx=0;\n  mouse.vy=0;\n});\n\n// Generate an initial explosion\nfunction explode() {\n  for (let p of particles) {\n    p.reset();\n    const angle = randRange(0, Math.PI*2);\n    const speed = randRange(3, 8);\n    p.vx = Math.cos(angle)*speed;\n    p.vy = Math.sin(angle)*speed;\n  }\n}\nexplode();\n\n// Animate\nfunction animate() {\n  ctx.fillStyle='rgba(0,0,0,0.2)';\n  ctx.fillRect(0, 0, width, height);\n\n  // Update particles\n  for (let p of particles) {\n    p.update();\n    p.draw();\n  }\n\n  // Connect close particles with fading lines\n  for (let i=0; i<particles.length; i++) {\n    for (let j=i+1; j<particles.length; j++) {\n      const dx=particles[i].x - particles[j].x;\n      const dy=particles[i].y - particles[j].y;\n      const dist=Math.sqrt(dx*dx+dy*dy);\n      if (dist<70){\n        ctx.strokeStyle=`rgba(255,255,255,${0.15 + 0.65*(1 - dist/70)})`;\n        ctx.lineWidth=0.5+0.5*(1 - dist/70);\n        ctx.beginPath();\n        ctx.moveTo(particles[i].x, particles[i].y);\n        ctx.lineTo(particles[j].x, particles[j].y);\n        ctx.stroke();\n      }\n    }\n  }\n\n  // Connect particles to mouse with strong lines and repel\n  if (mouse.x!==null && mouse.y!==null) {\n    for (let p of particles) {\n      const dx= p.x - mouse.x;\n      const dy= p.y - mouse.y;\n      const dist= Math.sqrt(dx*dx+dy*dy);\n      if (dist<mouse.radius) {\n        // Drag particles toward cursor\n        const force= (mouse.radius - dist)/mouse.radius * 0.3;\n        p.vx -= Math.cos(Math.atan2(dy, dx))*force;\n        p.vy -= Math.sin(Math.atan2(dy, dx))*force;\n\n        // Draw line to cursor\n        ctx.strokeStyle=`rgba(255,255,255,${0.4 + 0.6*(1 - dist/mouse.radius)})`;\n        ctx.lineWidth=1.2;\n        ctx.beginPath();\n        ctx.moveTo(p.x, p.y);\n        ctx.lineTo(mouse.x, mouse.y);\n        ctx.stroke();\n\n        // Add momentum to cursor\n        mouse.vx = (mouse.vx + Math.cos(Math.atan2(dy, dx))*force*0.2)*0.98;\n        mouse.vy = (mouse.vy + Math.sin(Math.atan2(dy, dx))*force*0.2)*0.98;\n      }\n    }\n    // Carrier momentum for mouse\n    mouse.x+=mouse.vx;\n    mouse.y+=mouse.vy;\n    mouse.vx*=0.95;\n    mouse.vy*=0.95;\n  }\n\n  requestAnimationFrame(animate);\n}\n\n// Optional: restart explosion on click\nwindow.addEventListener('click', explode);\n\nanimate();\n\n// Optional: periodic new explosions\nsetInterval(explode, 5000);\n</script>\n</body>\n</html>\n```\nðŸ’¡This version creates a catalyst explosion effect with thousands of particles radiating explosively, incorporating physics-based movement, color dynamics, interactive dragging, and continuous re-explosions for a dramatically more intense, mesmerizing visual experience."
  }
]