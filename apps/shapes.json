[
  {
    "role": "system",
    "content": "Generate a single page HTML app in a single Markdown code block.\nALWAYS end with a ONE-LINE information-rich summary of the change. Begin the line with ðŸ’¡"
  },
  {
    "role": "user",
    "content": "Animate shapes and patterns"
  },
  {
    "role": "assistant",
    "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"/>\n<title>Animated Shapes and Patterns</title>\n<style>\n  body {\n    margin: 0;\n    background: linear-gradient(135deg, #222, #444);\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    height: 100vh;\n  }\n  canvas {\n    background: #fff;\n    display: block;\n    border: 2px solid #333;\n  }\n</style>\n</head>\n<body>\n<canvas id=\"canvas\" width=\"600\" height=\"600\"></canvas>\n<script>\nconst canvas = document.getElementById('canvas');\nconst ctx = canvas.getContext('2d');\n\nconst shapesCount = 50;\nconst shapes = [];\n\nfunction randRange(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\n// Initialize random shapes with properties\nfor(let i=0; i<shapesCount; i++){\n  shapes.push({\n    x: randRange(0, canvas.width),\n    y: randRange(0, canvas.height),\n    size: randRange(10, 40),\n    shapeType: Math.random() > 0.5 ? 'circle' : 'square',\n    dx: randRange(-2, 2),\n    dy: randRange(-2, 2),\n    color: `hsl(${Math.floor(randRange(0, 360))}, 70%, 50%)`,\n    angle: randRange(0, Math.PI*2),\n    rotationSpeed: randRange(-0.02, 0.02),\n  });\n}\n\nfunction drawShape(shape) {\n  ctx.save();\n  ctx.translate(shape.x, shape.y);\n  ctx.rotate(shape.angle);\n  ctx.fillStyle = shape.color;\n  if (shape.shapeType === 'circle') {\n    ctx.beginPath();\n    ctx.arc(0, 0, shape.size / 2, 0, Math.PI * 2);\n    ctx.fill();\n  } else if (shape.shapeType === 'square') {\n    ctx.fillRect(-shape.size/2, -shape.size/2, shape.size, shape.size);\n  }\n  ctx.restore();\n}\n\nfunction updateShape(shape) {\n  shape.x += shape.dx;\n  shape.y += shape.dy;\n  if (shape.x < 0 || shape.x > canvas.width) shape.dx *= -1;\n  if (shape.y < 0 || shape.y > canvas.height) shape.dy *= -1;\n  shape.angle += shape.rotationSpeed;\n}\n\nfunction connectShapes() {\n  for(let i=0; i<shapes.length; i++){\n    for(let j=i+1; j<shapes.length; j++){\n      const s1 = shapes[i];\n      const s2 = shapes[j];\n      const dist = Math.hypot(s1.x - s2.x, s1.y - s2.y);\n      if(dist < 150){\n        ctx.strokeStyle = `hsla(${(s1.color.match(/\\d+/)[0]*1 + s2.color.match(/\\d+/)[0]*1)/2}, 70%, 50%, ${1 - dist/150})`;\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n        ctx.moveTo(s1.x, s1.y);\n        ctx.lineTo(s2.x, s2.y);\n        ctx.stroke();\n      }\n    }\n  }\n}\n\nfunction animate() {\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  for(const shape of shapes){\n    updateShape(shape);\n    drawShape(shape);\n  }\n  connectShapes();\n  requestAnimationFrame(animate);\n}\n\nanimate();\n</script>\n</body>\n</html>\n```\nðŸ’¡ This single-page HTML creates animated shapes (circles and squares) moving and rotating with connecting lines that fluctuate based on proximity, producing dynamic patterns."
  },
  {
    "role": "user",
    "content": "Improve this further - dramatically!"
  },
  {
    "role": "assistant",
    "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"/>\n<title>Dynamic Generative Shapes & Patterns</title>\n<style>\n  body {\n    margin: 0;\n    background: linear-gradient(135deg, #111, #222);\n    overflow: hidden;\n    font-family: sans-serif;\n  }\n  canvas {\n    display: block;\n    width: 100vw;\n    height: 100vh;\n    display: block;\n  }\n</style>\n</head>\n<body>\n<canvas id=\"canvas\"></canvas>\n<script>\nconst canvas = document.getElementById('canvas');\nconst ctx = canvas.getContext('2d');\n\nlet width = window.innerWidth;\nlet height = window.innerHeight;\ncanvas.width = width;\ncanvas.height = height;\n\nwindow.addEventListener('resize', () => {\n  width = window.innerWidth;\n  height = window.innerHeight;\n  canvas.width = width;\n  canvas.height = height;\n});\n\n// Generate a palette for vibrant colors\nconst palette = [\n  'hsl(0, 80%, 60%)',\n  'hsl(60, 80%, 60%)',\n  'hsl(120, 80%, 60%)',\n  'hsl(180, 80%, 60%)',\n  'hsl(240, 80%, 60%)',\n  'hsl(300, 80%, 60%)'\n];\n\nfunction randRange(min, max) { return Math.random() * (max - min) + min; }\n\nconst shapesCount = 80;\nconst shapes = [];\n\nfor(let i=0; i<shapesCount; i++){\n  shapes.push({\n    x: randRange(0, width),\n    y: randRange(0, height),\n    size: randRange(8, 30),\n    shapeType: Math.random() > 0.5 ? 'circle' : 'polygon',\n    sides: Math.random() > 0.5 ? 3 : Math.floor(randRange(4, 8)), // triangle or polygon\n    dx: randRange(-2.5, 2.5),\n    dy: randRange(-2.5, 2.5),\n    color: palette[Math.floor(randRange(0, palette.length))],\n    hueShift: randRange(0, 360),\n    hueSpeed: randRange(-0.5, 0.5),\n    rotation: randRange(0, Math.PI*2),\n    rotationSpeed: randRange(-0.02, 0.02),\n  });\n}\n\nfunction drawShape(shape){\n  ctx.save();\n  ctx.translate(shape.x, shape.y);\n  ctx.rotate(shape.rotation);\n  ctx.fillStyle = shape.color;\n  ctx.strokeStyle = 'rgba(255,255,255,0.2)';\n  ctx.lineWidth = 1;\n  if(shape.shapeType==='circle'){\n    ctx.beginPath();\n    ctx.arc(0,0, shape.size/2, 0, Math.PI*2);\n    ctx.fill();\n  } else {\n    const radius = shape.size/2;\n    ctx.beginPath();\n    for(let i=0; i<shape.sides; i++){\n      const angle = (Math.PI*2/shape.sides)*i;\n      const x = Math.cos(angle) * radius;\n      const y = Math.sin(angle) * radius;\n      if(i===0) ctx.moveTo(x,y);\n      else ctx.lineTo(x,y);\n    }\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n  }\n  ctx.restore();\n}\n\nfunction updateShape(shape){\n  shape.x += shape.dx;\n  shape.y += shape.dy;\n  if(shape.x<0 || shape.x > width) shape.dx *= -1;\n  if(shape.y<0 || shape.y > height) shape.dy *= -1;\n  shape.rotation += shape.rotationSpeed;\n  shape.hueShift += shape.hueSpeed;\n  shape.color = `hsl(${shape.hueShift % 360}, 80%, 55%)`;\n}\n\nfunction drawConnections() {\n  for(let i=0; i<shapes.length; i++){\n    for(let j=i+1; j<shapes.length; j++){\n      const s1 = shapes[i];\n      const s2 = shapes[j];\n      const dx = s1.x - s2.x;\n      const dy = s1.y - s2.y;\n      const dist = Math.hypot(dx, dy);\n      if(dist < 150){\n        ctx.strokeStyle = `hsla(${(s1.hueShift + s2.hueShift)/2}, 60%, 50%, ${1 - dist/150})`;\n        ctx.lineWidth = 0.5 + (150 - dist)/50;\n        ctx.beginPath();\n        ctx.moveTo(s1.x, s1.y);\n        ctx.lineTo(s2.x, s2.y);\n        ctx.stroke();\n      }\n    }\n  }\n}\n\nfunction animate() {\n  ctx.fillStyle = 'rgba(17,17,17,0.2)';\n  ctx.fillRect(0, 0, width, height);\n  for(const shape of shapes){\n    updateShape(shape);\n    drawShape(shape);\n  }\n  drawConnections();\n  requestAnimationFrame(animate);\n}\n\nanimate();\n</script>\n</body>\n</html>\n```\n\nðŸ’¡ Expanded to include multiple polygon shapes with variable sides, vibrant color palette, dynamic hue shifts, and adaptive connections, creating a smorgasbord of intricate animated patterns."
  },
  {
    "role": "user",
    "content": "Improve this further - dramatically!"
  },
  {
    "role": "assistant",
    "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"/>\n<title>Ultra Dynamic Shapes & Patterns</title>\n<style>\n  body {\n    margin: 0;\n    background: radial-gradient(circle at center, #111, #000);\n    overflow: hidden;\n  }\n  canvas {\n    display: block;\n    width: 100vw;\n    height: 100vh;\n  }\n</style>\n</head>\n<body>\n<canvas id=\"canvas\"></canvas>\n<script>\nconst canvas = document.getElementById('canvas');\nconst ctx = canvas.getContext('2d');\nlet W = window.innerWidth;\nlet H = window.innerHeight;\ncanvas.width = W;\ncanvas.height = H;\n\nwindow.addEventListener('resize', () => {\n  W = window.innerWidth;\n  H = window.innerHeight;\n  canvas.width = W;\n  canvas.height = H;\n});\n\n// Generate vibrant pulsating palette\nconst palette = [\n  'hsl(0, 100%, 60%)',\n  'hsl(30, 100%, 60%)',\n  'hsl(60, 100%, 60%)',\n  'hsl(120, 100%, 60%)',\n  'hsl(180, 100%, 60%)',\n  'hsl(240, 100%, 60%)',\n  'hsl(300, 100%, 60%)'\n];\n\nconst NUM_SHAPES = 150;\nconst shapes = [];\n\nfor(let i=0; i<NUM_SHAPES; i++) {\n  shapes.push({\n    x: Math.random() * W,\n    y: Math.random() * H,\n    size: Math.random() * 20 + 10,\n    shapeType: Math.random() > 0.5 ? 'circle' : 'polygon',\n    sides: Math.random() > 0.7 ? 3 : Math.floor(Math.random() * 6 + 3), // 3-8 sides\n    dx: (Math.random() - 0.5) * 3,\n    dy: (Math.random() - 0.5) * 3,\n    color: palette[Math.floor(Math.random() * palette.length)],\n    hueShift: Math.random() * 360,\n    hueSpeed: Math.random() * 0.4 - 0.2,\n    rotation: Math.random() * Math.PI*2,\n    rotSpeed: Math.random() * 0.03 - 0.015,\n    pulsate: Math.random() * 0.5 + 0.5,\n    scaleDir: Math.random() > 0.5 ? 1 : -1,\n  });\n}\n\nfunction drawShape(s) {\n  ctx.save();\n  ctx.translate(s.x, s.y);\n  ctx.rotate(s.rotation);\n  ctx.scale(1, 1);\n  ctx.fillStyle = s.color;\n  ctx.strokeStyle = 'rgba(255,255,255,0.2)';\n  ctx.lineWidth = 1 + Math.sin(s.hueShift/50)*0.5;\n  const size = s.size;\n  if(s.shapeType==='circle'){\n    ctx.beginPath();\n    ctx.arc(0,0,size/2,0,Math.PI*2);\n    ctx.fill();\n  } else {\n    ctx.beginPath();\n    for(let i=0; i<s.sides; i++) {\n      const angle = Math.PI*2/s.sides * i;\n      const x = Math.cos(angle) * size/2;\n      const y = Math.sin(angle) * size/2;\n      if(i===0) ctx.moveTo(x,y);\n      else ctx.lineTo(x,y);\n    }\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n  }\n  ctx.restore();\n}\n\nfunction updateShape(s) {\n  s.x += s.dx;\n  s.y += s.dy;\n  if(s.x<0 || s.x>W) s.dx *= -1;\n  if(s.y<0 || s.y>H) s.dy *= -1;\n  s.rotation += s.rotSpeed;\n  s.hueShift += s.hueSpeed;\n  // Pulsate size\n  s.size += s.pulsate * s.scaleDir;\n  if(s.size > 40 || s.size < 10) s.scaleDir *= -1;\n  // Hue shift\n  s.color = `hsl(${(s.hueShift)%360}, 80%, 55%)`;\n}\n\nfunction drawConnections() {\n  for(let i=0; i<shapes.length; i++) {\n    const s1 = shapes[i];\n    for(let j=i+1; j<shapes.length; j++) {\n      const s2 = shapes[j];\n      const dx = s1.x - s2.x;\n      const dy = s1.y - s2.y;\n      const dist = Math.hypot(dx, dy);\n      if(dist<180){\n        ctx.strokeStyle = `hsla(${(s1.hueShift + s2.hueShift)/2}, 70%, 60%, ${(1 - dist/180)*0.4})`;\n        ctx.lineWidth = 0.5 + (180 - dist)/60;\n        ctx.beginPath();\n        ctx.moveTo(s1.x, s1.y);\n        ctx.lineTo(s2.x, s2.y);\n        ctx.stroke();\n      }\n    }\n  }\n}\n\nfunction animate() {\n  ctx.fillStyle = 'rgba(17,17,17,0.2)';\n  ctx.fillRect(0,0,W,H);\n  for(const s of shapes){\n    updateShape(s);\n    drawShape(s);\n  }\n  drawConnections();\n  requestAnimationFrame(animate);\n}\n\nanimate();\n</script>\n</body>\n</html>\n```\n\nðŸ’¡ Transformed into an ultra-dense, expansive animated visualization with increased shape quantity, pulsating polygons, vivid shifting colors, dynamic rotation, and intricate connection lines for a dramatically more immersive generative pattern experience."
  }
]